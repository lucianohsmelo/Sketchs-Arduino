;*******************************************************************************
;*  Programa: Teste do Sensor de Umidade e Temperatura DHT-11 com LCD 16x2     *
;*  Desenvolvedor: Misael S. Sales                                             *
;*  Versão: 1.0                                                                *
;*  Data: 03/11/2012                                                           *
;*  PIC: Linha 16F de 40 pinos (Para usar em outros mude o nome das portas )   *
;*  Display: HD44780                                                           *
;*  Sensor: DHT-11                                                             *
;*  Licença: Livre para uso e modificação                                      *
;*                                                                             *
;*  MSS Eletrônica - www.msseletronica.com - msseletronica@hotmail.com.br      *
;*                                                                             *
;*******************************************************************************

;*******************************************************************************
;*  Ligações do LCD                                                            *
;*   D7 -> RD7 (PORTD 7)                                                       *
;*   D6 -> RD6 (PORTD 6)                                                       *
;*   D5 -> RD5 (PORTD 5)                                                       *
;*   D4 -> RD4 (PORTD 4)                                                       *
;*   RS -> RD3 (PORTD 3)                                                       *
;*   EN -> RD2 (PORTD 2)                                                       *
;*   R/W -> Deve ser conectado ao GND                                          *
;*   VCC -> Deve ser conectado ao +5V                                          *
;*   GND -> Deve ser conectado ao GND                                          *
;*   VO -> Deve ser conectado ao potenciômetro/trimpot de ajuste de brilho     *
;*******************************************************************************

;/******************************************************************************
;* Ligações do Sensor DHT-11                                                   *
;*  Out -> Pino RC0 do PORTC                                                   *
;*  "+" -> Deve ser conectado ao +5V                                           *
;*  "-" -> Deve ser conectado ao GND                                           *
;*******************************************************************************



;******************************** DEFINIÇÕES INICIAIS *******************************************************************

;DESENVOLVIDO PARA TRABALHAR COM CRISTAL DE 4MHz

	INCLUDE <P16F877A.INC>  ;INCLUIR UM ARQUIVO QUE NOMEIA TODOS OS INDEREÇOS FISICOS DO PIC
	
	__CONFIG _CP_OFF & _DEBUG_OFF & _WRT_OFF  & _CPD_OFF & _LVP_OFF & _BODEN_OFF & _PWRTE_ON & _WDT_OFF & _XT_OSC 

	ERRORLEVEL -302		;NÃO INTERPRETAR O ERRO DE NUMERO 302

;***************************** MACROS E OUTROS *************************************************************************
#DEFINE			BANCO_0 bcf STATUS,RP0 	;DEFINE COMO BANK0 O BIT RP0, EM '0'DO STATUS
#DEFINE			BANCO_1 bSf STATUS,RP0 	;DEFINE COMO BANK1 O BIT RP0, EM '0'DO STATUS

;***************************** NOMES PARA PORTA E PINOS ****************************************************************

#DEFINE	EN		PORTD,2	;ESTE PINO (RD2) DEVE SER CONECTADO AO ENABLE (EN) DO LCD
#DEFINE	RS		PORTD,3	;ESTE PINO (RD3) DEVE SER CONECTADO AO RS DO LCD
#DEFINE	LCD		PORTD	;OS PINOS RD4 A RD7 DO PORTD DEVE SER CONECTADO AOS D4 A D7 DO LCD

#DEFINE SENSOR PORTC,0	;PINO QUE DEVE SER CONECTADO AO PINO OUT DO SENSOR DHT-11
;VOCÊ DEVE ALIMENTAR O SENSOR, "+" NO VCC E "-" NO GND

;**************************** DECLARAÇÃO DE VARIAVEIS ******************************************************************
RH_1 	EQU 	0X21	;ARMAZENA O VALOR DA UMIDADE RELATIVA
RH_2 	EQU		0X22	;VEM SEMPRE EM ZERO
TEMP_1	EQU		0X23	;ARMAZENA O VALOR DA TEMPERATURA
TEMP_2 	EQU		0X24	;VEM SEMPRE EM ZERO
CKSUN	EQU		0X25	;CHECK SUM DA COMUNICAÇÃO (SOMA DOS QUATRO BYTES ANTERIORES)

BYTE_TEMP	EQU	0X26	;ARMAZENA O ULTIMO BYTE RECEBIDO TEMPORIAMENTE
TIME_OUT	EQU	0X27	;VARIÁVEL PARA CONTAR O TEMPO PARA TIME OUT
TEMPO		EQU	0X28	;ARMAZENA O TEMPO DO PULSO RECEBIDO (PARA LEITURA E INTERPRETAÇÃO DOS BITS RECEBIDOS)

PDel0		EQU	0X29	;VARIÁVEL USADA NO DELAY
PDel1		EQU	0X2A	;VARIÁVEL USADA NO DELAY
DELAY		EQU	0X2B	;VARIÁVEL COM O VALOR DE BASE PARA O DELAY (O TEMPO DO DELAY É 10mS X O VALOR DE DELAY)

FLAG_1		EQU	0X2C	;ENDEREÇO PARA FLAG

#DEFINE 	ERRO_SENSOR FLAG_1,0	;FLAG QUE INDICA QUE OCORREU ERRO AO LER O SENSOR
#DEFINE  	MSG_ERRO FLAG_1,1		;FLAG PARA INDICA QUE ESTA MOSTRANDO A MENSAGEM DE ERRO

COMANDO_TEMP_1	EQU	0X2D	;ARMAZENA O COMANDO ENVIADO PARA O LCD DE FORMA TEMPORÁRIA
COMANDO_TEMP_2	EQU	0X2E	;ARMAZENA O COMANDO ENVIADO PARA O LCD DE FORMA TEMPORÁRIA

DADO_TEMP		EQU	0X2F
AUX_1			EQU	0X30
AUX_2			EQU	0X31

;**************************** INICIALIZAÇÃO PARA GRAVAÇÃO **************************************************************
	ORG 0X00	;ENDEREÇO DO VETOR DE RESET
	GOTO		CONFIG

;**************************** TRATAMENTO DE INTERRUPÇÕES ***************************************************************
	ORG 0X04	;ENDEREÇO DO VETOR DE INTERRUPÇÃO
	RETFIE		;CASO OCORRA ALGUMA INTERRUPÇÃO VOLTA SEM TRATA-LA, POIS NÃO VAMOS USAR INTERRUPÇÕES NESTE PROGRAMA EXEMPLO

;**************************** CONFIGURAÇÕES DE INICIALIZAÇÃO ***********************************************************
CONFIG

	BANCO_1		;VAMOS PARA O BANCO 1

	MOVLW		B'00000011'	;SOMENTE OS PINOS RD1 E RD0 ESTÃO LIVRE PARA USO, O RESTANTE ESTA LIGADO AO LCD
	MOVWF		PORTD		;DEFININDO O PINO RD0 INICIALMENTE COMO ENTRADA E O RESTANTE COMO SAIDA

	MOVLW		B'11111111'
	MOVWF		PORTC		;SOMENTE O RC0 ESTA SENDO USADO PELO SENSOR, O RESTANTE ESTE LIVRE PARA USO


	MOVLW		B'00000000'		;PULL UPS DESABILITADOS (7), INT RB0 OFF (6), FONTE DE CLOCK PARA O TMR0 INTERNA (5), IRRELEVANTE NESTE CASO (4), PRESCALER PARA O TMR0 (3), PRESCALER 1: 2(2-0)
	MOVWF		OPTION_REG		;

	MOVLW		B'00000000'	;TODAS AS INTERRUPÇÕES DESABILITADAS
	MOVWF		INTCON
	
	BANCO_0

;**************************** INICIALIZAÇÃO *******************************************************
INICIO
	
	;INICIALIZANDO AS VARIÁVEIS
	CLRF	RH_1
	CLRF	RH_2
	CLRF	TEMP_1
	CLRF	TEMP_2
	CLRF	CKSUN
	CLRF	BYTE_TEMP
	CLRF	TIME_OUT
	CLRF	TEMPO

	BCF		ERRO_SENSOR
	BCF		MSG_ERRO

	CALL	INICIA_LCD	;CHAMA A ROTINA QUE INICIALIZA O LCD

;*************************** ENVIA UMA MENSAGEM PARA O LCD ***************************************
	MOVLW	.1	
	CALL	LINHA_1_LCD		;APONTA PARA O 2º CARACTER (COMEÇA EM ZERO) DA PRIMEIRA LINHA

	MOVLW	'E'
	CALL	CARACTER_LCD		;ENVIA O CARACTER
	MOVLW	'X'
	CALL	CARACTER_LCD
	MOVLW	'E'
	CALL	CARACTER_LCD
	MOVLW	'M'
	CALL	CARACTER_LCD
	MOVLW	'P'
	CALL	CARACTER_LCD
	MOVLW	'L'
	CALL	CARACTER_LCD
	MOVLW	'O'
	CALL	CARACTER_LCD
	MOVLW	' '
	CALL	CARACTER_LCD
	MOVLW	'D'
	CALL	CARACTER_LCD
	MOVLW	'H'
	CALL	CARACTER_LCD
	MOVLW	'T'
	CALL	CARACTER_LCD
	MOVLW	'1'
	CALL	CARACTER_LCD
	MOVLW	'1'
	CALL	CARACTER_LCD

	MOVLW	.1	
	CALL	LINHA_2_LCD			;APONTA PARA O 2º CARACTER (COMEÇA EM ZERO) DA SEGUNDA LINHA

	MOVLW	'M'
	CALL	CARACTER_LCD		;ENVIA O CARACTER
	MOVLW	'S'
	CALL	CARACTER_LCD
	MOVLW	'S'
	CALL	CARACTER_LCD
	MOVLW	' '
	CALL	CARACTER_LCD
	MOVLW	'E'
	CALL	CARACTER_LCD
	MOVLW	'L'
	CALL	CARACTER_LCD
	MOVLW	'E'
	CALL	CARACTER_LCD
	MOVLW	'T'
	CALL	CARACTER_LCD
	MOVLW	'R'
	CALL	CARACTER_LCD
	MOVLW	'O'
	CALL	CARACTER_LCD
	MOVLW	'N'
	CALL	CARACTER_LCD
	MOVLW	'I'
	CALL	CARACTER_LCD
	MOVLW	'C'
	CALL	CARACTER_LCD
	MOVLW	'A'
	CALL	CARACTER_LCD

	MOVLW	.100	
	MOVWF	DELAY		
	CALL	DELAY_10	;AGUARDA 1S (A ROTINA DELAY_10 GERA UM DELAY MULTIPLO DE 10mS, O TEMPO DEVE SER PASSADO EM DELAY)

	CALL	LIMPA_LCD	;LIMPA TODO TEXTO ESCRITO NO LCD

	CALL	MENSAGEM_TEMP_RH	;CHAMA A ROTINA QUE MONTA A MENSAGEM QUE FICARÁ MOSTRANDO A TEMPERATURA E A UMIDADE RELATIVA

;*************************** LOOP PRINCIPAL DO PROGRAMA *******************************************
LOOP	
	
	MOVLW	.10
	MOVWF	DELAY
	CALL	DELAY_10		;FAZ UMA NOVA LEITURA NO SENSOR A CADA 100ms

	CALL	LER_SENSOR		;ROTINA QUE LE O SENSOR

	BTFSC	ERRO_SENSOR
	GOTO	MSG_ERRO_SENSOR	;SE AO TENTAR LER O SENSOR ENCONTRAR ALGUM ERRO, EXIBE UMA MENSAGEM INDICANDO

	BTFSC	MSG_ERRO
	CALL	MENSAGEM_TEMP_RH	;SE O SENSOR NÃO ESTA MAIS EM ERRO, SE A MENSAGEM DE ERRO ESTIVER ATIVA, LIMPA ELA E COLOCA A MENSAGEM PARA EXIBIR OS DADOS
	
	MOVLW	.3	
	CALL	LINHA_1_LCD		;APONTA PARA O PRIMEIRO CARACTER DA UMIDADE RELATIVA
	MOVF	RH_1,W
			;RH_2 VEM SEMPRE 0 (ZERO)

	CALL	EXIBE_DADO		;CHAMA A ROTINA QUE CONVERTE O DADO E EXIBE NO LCD

	MOVLW	.5
	CALL	LINHA_2_LCD		;APONTA PARA O PRIMEIRO CARACTER DA TEMPERATURA
	MOVF	TEMP_1,W
			;TEMP_2 VEM SEMPRE 0 (ZERO)

	CALL	EXIBE_DADO
			
	GOTO LOOP

;****************************************** ROTINA PARA EXIBIR A MENSAGEM PARA TEMPERATURA E PARA UMIDADE (RH) ***************************************
MENSAGEM_TEMP_RH

	MOVLW	.0	
	CALL	LINHA_1_LCD	;APONTA PARA A SEGUNDA LINHA E 2 CARACTER

	MOVLW	'R'
	CALL	CARACTER_LCD
	MOVLW	'H'
	CALL	CARACTER_LCD
	MOVLW	':'
	CALL	CARACTER_LCD
	MOVLW	'0'
	CALL	CARACTER_LCD
	MOVLW	'0'
	CALL	CARACTER_LCD

	MOVLW	.5	
	CALL	LINHA_1_LCD	;APONTA PARA A SEGUNDA LINHA E 2 CARACTER

	MOVLW	'%'
	CALL	CARACTER_LCD

	MOVLW	.0	
	CALL	LINHA_2_LCD	;APONTA PARA A SEGUNDA LINHA E 2 CARACTER

	MOVLW	'T'
	CALL	CARACTER_LCD
	MOVLW	'E'
	CALL	CARACTER_LCD
	MOVLW	'M'
	CALL	CARACTER_LCD
	MOVLW	'P'
	CALL	CARACTER_LCD
	MOVLW	':'
	CALL	CARACTER_LCD
	MOVLW	'0'
	CALL	CARACTER_LCD
	MOVLW	'0'
	CALL	CARACTER_LCD

	MOVLW	.7	
	CALL	LINHA_2_LCD	;APONTA PARA A SEGUNDA LINHA E 2 CARACTER

	MOVLW	'C'
	CALL	CARACTER_LCD

	BCF		MSG_ERRO	;INDICA QUE A MENSAGEM ATUAL NÃO É A DE ERRO
	
	RETURN

;*************************** ROTINA PARA EXIBIR UMA MENSAGEM INFORMANDO ERRO AO LER O SENSOR ****
MSG_ERRO_SENSOR

	BTFSC	MSG_ERRO		;TESTA SE JÁ ESTA EXIBINDO A MENSAGEM DE ERRO
	GOTO	LOOP			;SE ESTIVER, SAI SEM MUDAR A MENSAGEM

	CALL	LIMPA_LCD		;LIMPA O QUE ESTIVER ESCRITO NO LCD
	
	MOVLW	.0	
	CALL	LINHA_1_LCD	;APONTA PARA A SEGUNDA LINHA E 2 CARACTER

	MOVLW	'E'
	CALL	CARACTER_LCD
	MOVLW	'R'
	CALL	CARACTER_LCD
	MOVLW	'R'
	CALL	CARACTER_LCD
	MOVLW	'0'
	CALL	CARACTER_LCD

	BSF		MSG_ERRO		;INFORMA QUE ESTA EXIBINDO A MENSAGEM DE ERRO

	GOTO	LOOP			;VOLTA PARA O LOOP

;*************************** ROTINA PARA EXIBIR O DADO DE FORMA BCD ******************************
;ESTA ROTINA TRANSFORMA UM NUMERO DE UM BYTE EM PARTES, OU SEJA, O NÚMERO 25, SERÁ 2 E 5 PARA MOSTRAR
; NO LCD

EXIBE_DADO	

	CALL	DIV_POR_10		;CHAMA A ROTINA QUE DIVIDE O VALOR POR 10 (O VALOR A SER DIVIDIDO VEIO NO 'W')
	MOVF	AUX_2,W			;ENVIA A PARTE INTEIRA (O DIGITO DA DEZENA)
	ADDLW	.48				;TRANSFORMA O NÚMERO EM CARACTER
	CALL	CARACTER_LCD	;EXIBE NO LCD
	
	MOVF	AUX_1,W			;EXIBE O RESTO DA DIVISÃO (A UNIDADE)
	ADDLW	.48				;TRANSFORMA O NÚMERO EM CARACTER
	CALL	CARACTER_LCD	;EXIBE NO LCD

	RETURN

DIV_POR_10		

	MOVWF	AUX_1
	CLRF	AUX_2

LOOP_DIV_POR_10

	MOVLW	.246
	ADDWF	AUX_1,W
	BTFSC	STATUS,C	;TESTA SE É MAIOR QUE 10
	GOTO	SUB_10

	RETURN

SUB_10

	MOVLW	.10
	SUBWF	AUX_1,F		;SUBTRAI 10 
	INCF	AUX_2,F		;INCREMENTA O VALOR DA AUX 2

	GOTO	LOOP_DIV_POR_10
	

;*************************** ROTINA PARA LER O SENSOR ********************************************
;ESTA ROTINA APENAS INICIA O PROCESSO, ELA CHAMARÁ OUTRAS ROTINAS

LER_SENSOR

	BCF		ERRO_SENSOR		;INICIA LIMPANDO O FLAG QUE INDICA ERRO NA LEITURA DO SENSOR

	CLRF	RH_1
	CLRF	RH_2	;RETORNARÁ SEMPRE EM ZERO
	CLRF	TEMP_1
	CLRF	TEMP_2	;RETORNARÁ SEMPRE EM ZERO
	CLRF	CKSUN	;TERÁ SEMPRE O RESULTADO DA SOMA ENTRE RH_1 + RH_2 + TEMP_1 + TEMP_2

	BANCO_1
	BCF		TRISC,0		;COLOCA O PINO QUE ESTA LIGADO AO SENSOR COMO SAIDA (PARA INICIAR A SOLICITAÇÃO DE DADOS)
	BANCO_0

	BCF		SENSOR		;COLOCA O PINO EM NÍVEL BAIXO (INICIA O PROCESSO DE SOLICITAÇÃO DE DADOS)
	MOVLW	.2
	MOVWF	DELAY		;GERA UM DELAY DE 20mS
	CALL	DELAY_10

	BSF		SENSOR		;COLOCA O PINO CONECTADO AO SENSOR EM NÍVEL ALTO
	
	BANCO_1
	BSF		TRISC,0		;COLOCANDO O PINO QUE ESTA LIGADO AO SENSOR COMO ENTRADA (PARA INICIAR A LEITURA DE DADOS)
	BANCO_0

	MOVLW	.200
	MOVWF	TIME_OUT	;TIME_OUT É O TEMPO MÁXIMO PARA FICAR AGUARDANDO A COMUNICAÇÃO COM O SENSOR (EM uS). SE O TEMPO ACABAR, ABORTA A LEITURA

LOOP_AGUARDA_RESP_SEN		;LOOP PARA AGUARDAR O SENSOR RESPONDER
	
	DECFSZ	TIME_OUT,F
	GOTO	CONT_LOOP_AGUARDA_RESP_SEN
	GOTO	ERRO_LER_SENSOR		;SE O TEMPO ACABOU, ENTÃO OCORREU UM ERRO AO LER O SENSOR, ENTÃO INDICA ISTO E SAI DA LEITURA DO SENSOR

CONT_LOOP_AGUARDA_RESP_SEN
	
	BTFSC	SENSOR
	GOTO	LOOP_AGUARDA_RESP_SEN	;ENQUANTO O PINO ESTIVE EM NIVEL ALTO FICA EM LOOP

	CLRF	TMR0		;REINICIA O TIMER0

;TESTANDO OS PRIMEIROS 80uS EM NÍVEL BAIXO
	MOVLW	.200
	MOVWF	TIME_OUT

LOOP_AGUARDA_RESP_SEN_2		;LOOP PARA AGUARDAR A SEGUNDA PARTE DA REPOSTA DO SENSOR (AINDA NÃO SÃO OS DADOS, CONSULTE O DATASHEET)

	DECFSZ	TIME_OUT,F
	GOTO	CONT_LOOP_AGUARDA_RESP_SEN_2
	GOTO	ERRO_LER_SENSOR

CONT_LOOP_AGUARDA_RESP_SEN_2

	BTFSS	SENSOR
	GOTO	LOOP_AGUARDA_RESP_SEN_2

	MOVF	TMR0,W
	MOVWF	TEMPO		;ARMAZENA O VALOR DO TIMER
	CLRF	TMR0		;REINICIA O TIMER0

	MOVLW	.226		
	ADDWF	TEMPO,W		
	BTFSS	STATUS,C		;TESTA SE O TEMPO É MAIOR OU IGUAL A 40 (LEMBRE-SE O O PRESCALER ESTA 1:2 -> 20 X 2 = 40uS) (TEMPO INFORMANDO NO DATASHEET É DE 80uS) ANTES DE RECEBER OS DADOS FICA 80uS EM NIVEL BAIXO
	GOTO	ERRO_LER_SENSOR

;TESTANDO OS PRIMEIROS 80uS EM NÍVEL ALTO
	MOVLW	.250
	MOVWF	TIME_OUT

LOOP_AGUARDA_RESP_SEN_3	;LOOP PARA AGUARDAR A SEGUNDA PARTE DA REPOSTA DO SENSOR (AINDA NÃO SÃO OS DADOS, CONSULTE O DATASHEET)

	DECFSZ	TIME_OUT,F
	GOTO	CONT_LOOP_AGUARDA_RESP_SEN_3
	GOTO	ERRO_LER_SENSOR

CONT_LOOP_AGUARDA_RESP_SEN_3

	BTFSC	SENSOR
	GOTO	LOOP_AGUARDA_RESP_SEN_3

	MOVF	TMR0,W
	MOVWF	TEMPO		;ARMAZENA O VALOR DO TIMER
	CLRF	TMR0		;REINICIA O TIMER0

	MOVLW	.226		
	ADDWF	TEMPO,W		
	BTFSS	STATUS,C		;TESTA SE O TEMPO É MAIOR OU IGUAL A 40 (LEMBRE-SE O PRESCALER ESTA 1:2 -> 20 X 2 = 40uS) (TEMPO INFORMANDO NO DATASHEET É DE 80uS) ANTES DE RECEBER OS DADOS FICA 80uS EM NIVEL BAIXO
	GOTO	ERRO_LER_SENSOR

;SE ATÉ AQUI ESTA TUDO OK, COMEÇA A RECEBER OS BYTES

	CALL	LER_BYTE_SENSOR	;CHAMA A ROTINA QUE LE UM BYTE
	MOVF	BYTE_TEMP,W		
	MOVWF	RH_1			;PASSA PARA A PRIMEIRA VARIÁVEL

	CALL	LER_BYTE_SENSOR
	MOVF	BYTE_TEMP,W
	MOVWF	RH_2

	CALL	LER_BYTE_SENSOR
	MOVF	BYTE_TEMP,W
	MOVWF	TEMP_1

	CALL	LER_BYTE_SENSOR
	MOVF	BYTE_TEMP,W
	MOVWF	TEMP_2

	CALL	LER_BYTE_SENSOR
	MOVF	BYTE_TEMP,W
	MOVWF	CKSUN

	RETURN					;RETORNA QUE OS DADOS EM SUAS VARIÁVEIS CORRESPONDENTES

ERRO_LER_SENSOR

	BSF		ERRO_SENSOR		;SE OCORRER UM ERRO NA LEITURA DO SENSOR, INFORMA ATRAVÉS DESTE FLAG

	RETURN	

;*************************************** ROTINA QUE LE 1(UM) BYTE ENVIADO PELO SENSOR ***************************
LER_BYTE_SENSOR	;ROTINA PARA LER OS BIT´s E MONTAR UM BYTE

	CLRF	BYTE_TEMP

;************ BIT 7 *********************

LOOP_LER_BIT_1_7		;O SENSOR ENVIA PRIMEIRO OS BIT´S MAIS SIGNIFICATIVOS, OU SEJA, COMEÇA DO 7, DEPOIS 6 E ASSIM POR DIANTE

	BTFSS	SENSOR
	GOTO	LOOP_LER_BIT_1_7	;FICA EM LOOP AGUARDADO SAIR DO NIVEL 0(ZERO)

	MOVF	TMR0,W
	MOVWF	TEMPO		;ARMAZENA O VALOR DO TIMER
	CLRF	TMR0		;REINICIA O TIMER0

	MOVLW	.243		
	ADDWF	TEMPO,W		
	BTFSS	STATUS,C	;TESTA SE O TEMPO É MAIOR OU IGUAL A 26 (LEMBRE-SE O O PRESCALER ESTA 1:2 -> 13 X 2 = 26uS) (TEMPO INFORMANDO NO DATASHEET É DE 50uS) ESTE É O INICIO DO BIT
	GOTO	ERRO_LER_SENSOR

LOOP_LER_BIT_2_7

	BTFSC	SENSOR
	GOTO	LOOP_LER_BIT_2_7	;FICA EM LOOP AGUARDADO SAIR DO NIVEL 0(ZERO)

	MOVF	TMR0,W
	MOVWF	TEMPO		;ARMAZENA O VALOR DO TIMER
	CLRF	TMR0		;REINICIA O TIMER0

	MOVLW	.238		
	ADDWF	TEMPO,W		
	BTFSC	STATUS,C		;TESTA SE O TEMPO É MAIOR OU IGUAL A 36 (LEMBRE-SE O O PRESCALER ESTA 1:2 -> 18 X 2 = 36uS) (TEMPO INFORMANDO NO DATASHEET É DE 70uS PARA BIT 1 OU 26-28uS PARA BIT 0(ZERO)) ESTE É O INICIO DO BIT
	BSF		BYTE_TEMP,7		;SE O BIT RECEBIDO FOR 1, COLOCA EM 1 O BIT 7 (COMEÇA RECEBER OS BIT´s MAIS SIGNIFICATIVOS)
							;SE O BIT RECEBIDO FOR 0, NÃO PRECISA ALTERAR O VALOR DO BIT, POIS INCIALMENTE ELE JÁ É 0 (ZERO)

;************ BIT 6 *********************

LOOP_LER_BIT_1_6

	BTFSS	SENSOR
	GOTO	LOOP_LER_BIT_1_6	;FICA EM LOOP AGUARDADO SAIR DO NIVEL 0(ZERO)

	MOVF	TMR0,W
	MOVWF	TEMPO		;ARMAZENA O VALOR DO TIMER
	CLRF	TMR0		;REINICIA O TIMER0

	MOVLW	.243		
	ADDWF	TEMPO,W		
	BTFSS	STATUS,C
	GOTO	ERRO_LER_SENSOR

LOOP_LER_BIT_2_6

	BTFSC	SENSOR
	GOTO	LOOP_LER_BIT_2_6	;FICA EM LOOP AGUARDADO SAIR DO NIVEL 0(ZERO)

	MOVF	TMR0,W
	MOVWF	TEMPO		;ARMAZENA O VALOR DO TIMER
	CLRF	TMR0		;REINICIA O TIMER0

	MOVLW	.238		
	ADDWF	TEMPO,W		
	BTFSC	STATUS,C	
	BSF		BYTE_TEMP,6	
	
;************ BIT 5 *********************

LOOP_LER_BIT_1_5

	BTFSS	SENSOR
	GOTO	LOOP_LER_BIT_1_5	;FICA EM LOOP AGUARDADO SAIR DO NIVEL 0(ZERO)

	MOVF	TMR0,W
	MOVWF	TEMPO		;ARMAZENA O VALOR DO TIMER
	CLRF	TMR0		;REINICIA O TIMER0

	MOVLW	.243		
	ADDWF	TEMPO,W		
	BTFSS	STATUS,C
	GOTO	ERRO_LER_SENSOR

LOOP_LER_BIT_2_5

	BTFSC	SENSOR
	GOTO	LOOP_LER_BIT_2_5	;FICA EM LOOP AGUARDADO SAIR DO NIVEL 0(ZERO)

	MOVF	TMR0,W
	MOVWF	TEMPO		;ARMAZENA O VALOR DO TIMER
	CLRF	TMR0		;REINICIA O TIMER0

	MOVLW	.238		
	ADDWF	TEMPO,W		
	BTFSC	STATUS,C
	BSF		BYTE_TEMP,5

;************ BIT 4 *********************

LOOP_LER_BIT_1_4

	BTFSS	SENSOR
	GOTO	LOOP_LER_BIT_1_4	;FICA EM LOOP AGUARDADO SAIR DO NIVEL 0(ZERO)

	MOVF	TMR0,W
	MOVWF	TEMPO		;ARMAZENA O VALOR DO TIMER
	CLRF	TMR0		;REINICIA O TIMER0

	MOVLW	.243		
	ADDWF	TEMPO,W		
	BTFSS	STATUS,C	
	GOTO	ERRO_LER_SENSOR

LOOP_LER_BIT_2_4

	BTFSC	SENSOR
	GOTO	LOOP_LER_BIT_2_4	;FICA EM LOOP AGUARDADO SAIR DO NIVEL 0(ZERO)

	MOVF	TMR0,W
	MOVWF	TEMPO		;ARMAZENA O VALOR DO TIMER
	CLRF	TMR0		;REINICIA O TIMER0

	MOVLW	.238		
	ADDWF	TEMPO,W		
	BTFSC	STATUS,C
	BSF		BYTE_TEMP,4

;************ BIT 3 *********************

LOOP_LER_BIT_1_3

	BTFSS	SENSOR
	GOTO	LOOP_LER_BIT_1_3	;FICA EM LOOP AGUARDADO SAIR DO NIVEL 0(ZERO)

	MOVF	TMR0,W
	MOVWF	TEMPO		;ARMAZENA O VALOR DO TIMER
	CLRF	TMR0		;REINICIA O TIMER0

	MOVLW	.243		
	ADDWF	TEMPO,W		
	BTFSS	STATUS,C
	GOTO	ERRO_LER_SENSOR

LOOP_LER_BIT_2_3

	BTFSC	SENSOR
	GOTO	LOOP_LER_BIT_2_3	;FICA EM LOOP AGUARDADO SAIR DO NIVEL 0(ZERO)

	MOVF	TMR0,W
	MOVWF	TEMPO		;ARMAZENA O VALOR DO TIMER
	CLRF	TMR0		;REINICIA O TIMER0

	MOVLW	.238		
	ADDWF	TEMPO,W		
	BTFSC	STATUS,C
	BSF		BYTE_TEMP,3

;************ BIT 2 *********************

LOOP_LER_BIT_1_2

	BTFSS	SENSOR
	GOTO	LOOP_LER_BIT_1_2	;FICA EM LOOP AGUARDADO SAIR DO NIVEL 0(ZERO)

	MOVF	TMR0,W
	MOVWF	TEMPO		;ARMAZENA O VALOR DO TIMER
	CLRF	TMR0		;REINICIA O TIMER0

	MOVLW	.243		
	ADDWF	TEMPO,W		
	BTFSS	STATUS,C	
	GOTO	ERRO_LER_SENSOR

LOOP_LER_BIT_2_2

	BTFSC	SENSOR
	GOTO	LOOP_LER_BIT_2_2	;FICA EM LOOP AGUARDADO SAIR DO NIVEL 0(ZERO)

	MOVF	TMR0,W
	MOVWF	TEMPO		;ARMAZENA O VALOR DO TIMER
	CLRF	TMR0		;REINICIA O TIMER0

	MOVLW	.238		
	ADDWF	TEMPO,W		
	BTFSC	STATUS,C	
	BSF		BYTE_TEMP,2	

;************ BIT 1 *********************

LOOP_LER_BIT_1_1

	BTFSS	SENSOR
	GOTO	LOOP_LER_BIT_1_1	;FICA EM LOOP AGUARDADO SAIR DO NIVEL 0(ZERO)

	MOVF	TMR0,W
	MOVWF	TEMPO		;ARMAZENA O VALOR DO TIMER
	CLRF	TMR0		;REINICIA O TIMER0

	MOVLW	.243		
	ADDWF	TEMPO,W		
	BTFSS	STATUS,C		
	GOTO	ERRO_LER_SENSOR

LOOP_LER_BIT_2_1

	BTFSC	SENSOR
	GOTO	LOOP_LER_BIT_2_1	;FICA EM LOOP AGUARDADO SAIR DO NIVEL 0(ZERO)

	MOVF	TMR0,W
	MOVWF	TEMPO		;ARMAZENA O VALOR DO TIMER
	CLRF	TMR0		;REINICIA O TIMER0

	MOVLW	.238		
	ADDWF	TEMPO,W		
	BTFSC	STATUS,C	
	BSF		BYTE_TEMP,1	

;************ BIT 0 *********************

LOOP_LER_BIT_1_0

	BTFSS	SENSOR
	GOTO	LOOP_LER_BIT_1_0	;FICA EM LOOP AGUARDADO SAIR DO NIVEL 0(ZERO)

	MOVF	TMR0,W
	MOVWF	TEMPO		;ARMAZENA O VALOR DO TIMER
	CLRF	TMR0		;REINICIA O TIMER0

	MOVLW	.243		
	ADDWF	TEMPO,W		
	BTFSS	STATUS,C	
	GOTO	ERRO_LER_SENSOR

LOOP_LER_BIT_2_0

	BTFSC	SENSOR
	GOTO	LOOP_LER_BIT_2_0	;FICA EM LOOP AGUARDADO SAIR DO NIVEL 0(ZERO)

	MOVF	TMR0,W
	MOVWF	TEMPO		;ARMAZENA O VALOR DO TIMER
	CLRF	TMR0		;REINICIA O TIMER0

	MOVLW	.238		
	ADDWF	TEMPO,W		
	BTFSC	STATUS,C		
	BSF		BYTE_TEMP,0		


	RETURN	
	

;*************************************** ROTINAS RELACIONADAS AO LCD *********************************************

CARACTER_LCD	;ROTINA PARA ENVIAR UM CARACTER PARA O LCD
;ANTES DE CHAMAR ESTA ROTINA, DEVE SE PASSAR O COMANDO PARA 'W'

	BSF		RS	
	BCF		EN

	MOVWF	COMANDO_TEMP_1	;SALVA UMA CÓPIA DO COMANDO
	MOVWF	COMANDO_TEMP_2	;SALVA UMA CÓPIA DO COMANDO
	
	
	BCF		LCD,7	;LIMPANDO OS BIT´s MAIS SIGNIFICATIVOS DA PORTA LIGADA AO LCD
	BCF		LCD,6
	BCF		LCD,5
	BCF		LCD,4

	BCF		COMANDO_TEMP_1,0		;LIMPANDO O BIT´s MENOS SIGNIFICATIVOS DO COMANDO
	BCF		COMANDO_TEMP_1,1
	BCF		COMANDO_TEMP_1,2
	BCF		COMANDO_TEMP_1,3

	MOVF	COMANDO_TEMP_1,W
	ADDWF	LCD,F					;ENVIA O COMANDO PARA O LCD SEM ALTERAR O ESTADO DOS OUTROS PINOS DO PORT LIGADO AO LCD		

	BSF		EN
	MOVLW	.1
	MOVWF	DELAY
	CALL	DELAY_10	;PODE SER CRIANDO UM DELAY MENOR (2ms) PARA QUE ISTO FIQUE MAIS RÁPIDO

	BCF		EN

	BCF		LCD,7	;LIMPANDO OS BIT´s MAIS SIGNIFICATIVOS DA PORTA LIGADA AO LCD
	BCF		LCD,6
	BCF		LCD,5
	BCF		LCD,4

	SWAPF	COMANDO_TEMP_2,F

	BCF		COMANDO_TEMP_2,0		;LIMPANDO O BIT´s MENOS SIGNIFICATIVOS DO COMANDO
	BCF		COMANDO_TEMP_2,1
	BCF		COMANDO_TEMP_2,2
	BCF		COMANDO_TEMP_2,3

	MOVF	COMANDO_TEMP_2,W
	ADDWF	LCD,F					;ENVIA O COMANDO PARA O LCD SEM ALTERAR O ESTADO DOS OUTROS PINOS DO PORT LIGADO AO LCD		

	BSF		EN
	MOVLW	.1
	MOVWF	DELAY
	CALL	DELAY_10	;PODE SER CRIANDO UM DELAY MENOR (2ms) PARA QUE ISTO FIQUE MAIS RÁPIDO

	BCF		EN

	RETURN

;**********************
LINHA_1_LCD	;ROTINA QUE APONTA PARA A PRIMEIRA LINHA DO LCD, A POSIÇÃO DO CARACTER DEVE SER PASSADO NO 'W' RESPEITANDO O LIMITE DE 16 (0 a 15)

	ADDLW	B'10000000'
	CALL 	COMANDO_LCD	;ENVIA O COMANDO COM A POSIÇÃO PARA O LCD
	
	RETURN	

;**********************
LINHA_2_LCD	;ROTINA QUE APONTA PARA A SEGUNDA LINHA DO LCD, A POSIÇÃO DO CARACTER DEVE SER PASSADO NO 'W' RESPEITANDO O LIMITE DE 16 (0 a 15)

	ADDLW	B'11000000'
	CALL 	COMANDO_LCD	;ENVIA O COMANDO COM A POSIÇÃO PARA O LCD

	RETURN

;*********************
INICIO_LCD	;ROTINA QUE APONTA PARA O INICIO DO LCD

	MOVLW	B'00000010'	;Cursor no inicio(1)
	CALL	COMANDO_LCD

	RETURN

;*********************
LIMPA_LCD	;ROTINA QUE LIMPA OS DADOS ESCRITOS NO LCD

	MOVLW	B'00000001'	;limpa display (0)
	CALL	COMANDO_LCD

	RETURN

;*********************
INICIA_LCD	;ROTINA PARA CHAMAR AS ROTINAS NECESSÁRIAS PARA INICIALIZAR O LCD

	CALL	LCD_4_BIT	;ROTINA QUE INICIALIZA O LCD PARA TRABALHAR A 4 BIT´s DE DADOS

	MOVLW	B'00101000'	;LCD 4 bits(4), 2 linhas(3), caracter 5*7(2)
	CALL	COMANDO_LCD	

	MOVLW	B'00001100'	;Display ligado(2), cursor desligado(1), sem cursor(0)
	CALL	COMANDO_LCD

	MOVLW	B'00010100'	;Cursor movimenta(3), Cursor movimenta para a direita a cada caracter(2) - irrelevante, pois o cursor esta desligado
	CALL	COMANDO_LCD

	MOVLW	B'00000010'	;Cursor no inicio(1)
	CALL	COMANDO_LCD

	MOVLW	B'00000001'	;Limpa o LCD
	CALL	COMANDO_LCD

	RETURN

;******************
COMANDO_LCD	;ROTINA PARA ENVIAR UM COMANDO ESPECÍFICO PARA O LCD
;ANTES DE CHAMAR ESTA ROTINA, DEVE SE PASSAR O COMANDO PARA 'W'

	BCF		RS
	BCF		EN

	MOVWF	COMANDO_TEMP_1	;SALVA UMA CÓPIA DO COMANDO
	MOVWF	COMANDO_TEMP_2	;SALVA UMA CÓPIA DO COMANDO
	
	
	BCF		LCD,7	;LIMPANDO OS BIT´s MAIS SIGNIFICATIVOS DA PORTA LIGADA AO LCD
	BCF		LCD,6
	BCF		LCD,5
	BCF		LCD,4

	BCF		COMANDO_TEMP_1,0		;LIMPANDO O BIT´s MENOS SIGNIFICATIVOS DO COMANDO
	BCF		COMANDO_TEMP_1,1
	BCF		COMANDO_TEMP_1,2
	BCF		COMANDO_TEMP_1,3

	MOVF	COMANDO_TEMP_1,W
	ADDWF	LCD,F					;ENVIA O COMANDO PARA O LCD SEM ALTERAR O ESTADO DOS OUTROS PINOS DO PORT LIGADO AO LCD		

	BSF		EN
	MOVLW	.1
	MOVWF	DELAY
	CALL	DELAY_10	;PODE SER CRIANDO UM DELAY MENOR (2ms) PARA QUE ISTO FIQUE MAIS RÁPIDO

	BCF		EN

	BCF		LCD,7	;LIMPANDO OS BIT´s MAIS SIGNIFICATIVOS DA PORTA LIGADA AO LCD
	BCF		LCD,6
	BCF		LCD,5
	BCF		LCD,4

	SWAPF	COMANDO_TEMP_2,F

	BCF		COMANDO_TEMP_2,0		;LIMPANDO O BIT´s MENOS SIGNIFICATIVOS DO COMANDO
	BCF		COMANDO_TEMP_2,1
	BCF		COMANDO_TEMP_2,2
	BCF		COMANDO_TEMP_2,3

	MOVF	COMANDO_TEMP_2,W
	ADDWF	LCD,F					;ENVIA O COMANDO PARA O LCD SEM ALTERAR O ESTADO DOS OUTROS PINOS DO PORT LIGADO AO LCD		

	BSF		EN
	MOVLW	.1
	MOVWF	DELAY
	CALL	DELAY_10	;PODE SER CRIANDO UM DELAY MENOR (2ms) PARA QUE ISTO FIQUE MAIS RÁPIDO

	BCF		EN

	RETURN	
	
;********************************
LCD_4_BIT	;ROTINA PARA INICIALIZAR O LCD PARA TRABALHAR A 4 BIT´s DE DADOS (PARA ENTENDER MELHOR, CONSULTE O COMANDO 0B00100000 NO DATASHEET (RS = 0))

	BCF		RS
	BCF		EN

	BCF		LCD,7	;LIMPANDO OS BIT´s MAIS SIGNIFICATIVOS DA PORTA LIGADA AO LCD
	BCF		LCD,6
	BCF		LCD,5
	BCF		LCD,4

	MOVLW	B'00100000'
	ADDWF	LCD,F		;ENVIA O COMANDO PARA O LCD SEM ALTERAR O ESTADO DOS OUTROS PINOS DO PORT LIGADO AO LCD

	BSF		EN
	MOVLW	.1
	MOVWF	DELAY
	CALL	DELAY_10	;PODE SER CRIANDO UM DELAY MENOR (2ms) PARA QUE ISTO FIQUE MAIS RÁPIDO

	BCF		EN

	RETURN


;*************************************** ROTINAS DE TEMPO ********************************************************

;ESTA ROTINA CRIA UM DELAY MULTIPLO DE 10mS
;	-> A BASE DE TEMPO DEVE SER PASSADO PARA A VARIAVEL DELAY ANTES DE CHAMAR ESTA ROTINA
; 	-> O VALOR MÁXIMO PARA A VARIÁVEL DELAY É 255, QUE DA UM TOTAL DE 2,55s

DELAY_10		;A BASE DE TEMPO DESTA ROTINA É DE 10ms

	MOVLW		.8        ; 1 set number of repetitions (B)
    MOVWF	    PDel0     ; 1 |

DELAY_10_1  
	
	MOVLW		.249      ; 1 set number of repetitions (A)
    MOVWF 		PDel1     ; 1 |

DELAY_10_2  

	CLRWDT              ; 1 clear watchdog
    CLRWDT              ; 1 cycle delay
    DECFSZ		PDel1, 1  ; 1 + (1) is the time over? (A)
    GOTO      	DELAY_10_2    ; 2 no, loop
    DECFSZ		PDel0,  1 ; 1 + (1) is the time over? (B)
    GOTO	    DELAY_10_1    ; 2 no, loop

DELAY_10_L1

	GOTO		DELAY_10_L2         ; 2 cycles delay

DELAY_10_L2
	
	CLRWDT              ; 1 cycle delay

	DECFSZ		DELAY,F
	GOTO		DELAY_10		;EXECUTA O NUMERO DE VEZES DEFINIDO NA VARIAVEL DALAY
	RETURN

	END

